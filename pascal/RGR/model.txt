Часть II. Программное исчисление.

Следующий шаг.

Часть I была посвящена тому, как писать  программы, решая простые задачи с использованием простого языка программирования, CF Pascal. Часть II выводит нас на следующий уровень, предлагая нам осознать обобщенные математические концепции программирования, которым подчиняются все программы. При этом наша цель остается неизменной – изучение программирования методом проб и ошибок, используя подход сходный с обучением слепой печати на клавиатуре. В части I мы рассматривали средства языка, часть II будет знакомить нас с технологиями систематического программирования.
Компактный CFPascal был подходящим выбором для части I, поскольку  он позволял нам концентрироваться на программировании, а не на изучении языка программирования. Для части II он также хорошо подходит, потому что он позволит нам решить следующую задачу: рассматривать программы как математические объекты, более сложные, чем просто строки символов. Рассмотренные идеи будут масштабироваться вне зависимости от роста размеров программ, подобно тому, как, обучившись делению трехзначных чисел, мы сможем в дальнейшем делить тридцатизначные.
Понимание программ как математических объектов организовано как программное исчисление, которое ориентировано в основном на семантику программ, а не на синтаксис.

Что такое программное исчисление.

Вводный курс в дифференциальное исчисление  в математике основывается на концепции гладкой функции, принимающие вещественные (real) значения. Исчисление связано с понятием вычисления двух связанных функций: производной и первообразной (интеграла) для данной функции. Такие вычисления очень значимы в физике и технических дисциплинах, собственно современная физика и производные науки без этих вычислений невозможны. Функции дифференциального исчисления имеют физический смысл, производная – это интенсивность изменения величины, например скорости движения (ускорение), интеграл – площадь подкривой.
Нет ничего неожиданного в том, что операции вычисления производной и первообразной для данной функции являются взаимно обратными. 
Фундаментальными объектами программного исчисления так же являются функции, но эти функции дискретны, то есть определены не на множестве вещественных чисел, а на конечном множестве символов и других математических объектов сформированных из символов. Такие функции задают значение программ. Поскольку любая программа на CFPaskal заставляет Паскаль-машину преобразовывать входные данные в выходные, результат работы такой программы может быть описан с помощью функции, преобразующей множество символов из INPUT во множество символов OUTPUT.
 
В программном исчислении существуют две основные задачи. Первая,  для данной программы как синтаксического объекта найти функцию, описывающую ее значения. Вторая, имея функцию, описывающую значение программы, найти программу с таким значением. Вторая задача ведет нас к систематическим методам проектирования и разработки программ, а первая – к систематическим методам верификации правильности программ. 

Способность вывода функции значения для данной программы в программном исчислении является очень значимой для компьютерных наук. Во-первых, она позволяет проводить математическое доказательство корректности программ, а именно: задает ли программа корректное поведение компьютера любых возможных входных данных. Отладка некорректных программ является принципиальной причиной низкой продуктивности процесса разработки программного обеспечения. Способность выводить функции из программ систематическим образом является даже более важной, потому что делает возможным шаг за шагом сформировать дисциплину разработки программ, которые корректны изначально и не требуют отладки. Систематическое программирование как дисциплина является основной целью части II.     
Математическими основами программного исчисления являются пять дискретных математических структур символьных данных, а именно:
•	строки – такие как последовательность символов в предложении
•	списки – такие как последовательность слов в предложении (с учетом порядка следования)
•	множества - такие как набор слов в предложении (без учета порядка следования и с исключением дублирований)
•	отношения – такие как множество пар слов следующих друг за другом в предложении
•	функции - такие как множество пар слов, следующих друг за другом в предложении, в которых ни одно слово не встречается дважды.

Эти пять структур имеют важное свойство - они могут быть рассмотрены на разных уровнях формализации, от чистой математики до неформальных описаний на английском (русском) языке. Некоторые множества могут быть более легко и точно описаны на английском, чем с помощью математики и не перестают от этого быть множествами. Многие задачи в программировании лучше описываются на английском языке, чем с помощью математики, и нам необходимо рассматривать вопросы корректности программ вне зависимости от способа их описания.
Рассмотрение программ как математических объектов унифицирует и упрощает вопросы проектирования программ и достижения их корректности. Человечество не так давно занимается компьютерными программами,  но они являются одним из самых логически сложных произведенных им артефактов. Для преодоления сложности у человечества нет другого средства кроме математики. Поскольку математика изменялась последние пятьсот лет под воздействием потребностей физики и технических наук, так что можно надеяться, что потребности компьютерных наук также будут иметь определяющее влияние на математику в течение следующих ста лет.

Программы как математические объекты

Фундаментальный подход в компьютерных науках предполагает понимание программ как математических объектов, о которых можно рассуждать с математической строгостью. Математически программа больше, чем ее представление на языке программирования,  например таком как CFPascal. Аналогичная ситуация с числами. Число тринадцать – математический объект, который имеет свойство быть тринадцатью вне зависимости от того, как это число будет представлено в письменной или устной форме: словом «двенадцать», набором цифр «12», или в римском варианте «XII» или «дюжина». Все эти представления являются строками символов. Разница между числом и его устным или письменным обозначением в том, что число имеет определенные математические свойства, не зависимые от того, как мы называем или обозначаем это число. Двенадцать – это на два больше, чем десять, четное, кратное трем, четырем, шести и т.д.
Выделение концепции натуральных чисел в виде набора аксиом было большим достижением в математике, сделанным итальянским математиком Джузеппе Пеано, который жил на рубеже XIX и XX веков.
Пеано ввел два понятие целого (натурального) числа, понятие следования одного числа непосредственно за другим в натуральном ряде и понятие начального члена натурального ряда (за который можно принять 0 или 1). Эти понятия связаны между собой пятью аксиомами, которые можно рассматривать как аксиоматическое определение указанных основных понятий.
1)	0 есть натуральное число; 
2)	следующее за натуральным числом есть натуральное число; 
3)	0 не следует ни за каким натуральным числом; 
4)	если натуральное число а следует за натуральным числом b и за натуральным числом с, то b и с тождественны; 
5)	если какое-либо предложение доказано для 0 и если из допущения, что оно верно для натурального числа n, вытекает, что оно верно для следующего за п натурального числа, то это предложение верно для всех натуральных чисел. 
Последняя аксиома - аксиома полной индукции - даёт возможность доказывать общие свойства натуральных чисел.
Обычные названия чисел могут быть интерпретированы как сокращения для неуклюжих названий, которые встречаются в работе Пеано. Пусть следующий для целого числа n будет обозначаться s(n). Тогда сокращения будут такими:
1 	для s(0)
2 	для s(1) = s(s(0))
…
10	для s(9) = s(s(8)) = …
…
100 	для s(99) = s(s(98)) = …
Математические свойства чисел 0, 1, 2 , …, 10, …, 100,… зависят только от 0 и s, а не от представления их с помощью цифр. Например, 10 > 8, потому что существует выражение 
10 = s(s(8)), 5 = 3 + 2, потому что 5 = s(s(3)) (s использовано дважды). Нужно заметить, что представления чисел ни разу не использованы в работе Пеано, за исключением символа 0, который достаточно условно взят как символ начала последовательности.
Большинство людей имеют дело с обычными представлениями чисел, например при сложении, делении и т.д. Понимание чисел как математических объектов, например, через аксиомы Пеано, обычно является областью деятельности тех, кто изучает математику в соответствующих вузах. Но операции, которые мы выполняем над числами, используя их некоторые представления, основаны именно на свойствах чисел. Например, при нахождении квадратного корня из 100 мы используем свойства десятичного представления числа и легко получаем 10, та же самая процедура будет сложнее, если мы будем пользоваться римским представлением чисел, но даст тот же результат, потому что вычисление квадратного корня базируется на свойстве числа, а не на его представлении.
Подобно тому, как дети в школе учатся вычислять квадратный корень, не понимая разницы между числом и его десятичным представлением, многие учатся программировать, не имея представления о программах как о математических объектах. Пока программы маленькие и простые, все идет нормально, но по мере нарастания сложности программ, понимание их как математических объектов и умение рассуждать о программах с математической строгостью, позволяет добиться интеллектуального контроля над процессом разработки.

[будущие инженеры должны это знать, уже сейчас некоторые теряют интеллектуальный контроль на простых программах, пример с IFSort3б или впадают в ступор неверно поставив точку с запятой]

Свойство программ, которое не зависит от их представления, синтаксиса – управление поведением компьютером. Программа, которая сортирует строку, конечно имеет представление, выраженное в соответствии с синтаксическими правилами, но суть того, что она делает – сортировка. Может существовать множество программ на CF Pascal, которые сортируют строку, подобно тому как число 12 может быть получено из 11+1, 10+2, 7+5 и т.д. Аналогичные программ могут быть написаны на других языках программирования, таких как BASIC или С. Каждый язык программирования – всего лишь средство выражения способа решения задачи аналогично тому, как арабские или римские цифры представляют натуральные числа. Функциональное поведение программы независимо от ее представления на том или ином языке программирования и конкретной формы для выбранного языка.
Таким образом, понимание программ как математических объектов – это понимание функционального поведения программ по управлению компьютером.

Синтаксис и семантика CF Pascal

Программы на CF Pascal, как сложные объекты, могут быть рассмотрены с разных точек зрения. Персонаж, у которого программа не компилируется, может думать, что главное – соблюдение синтаксиса. Специалист по документированию – может думать, что наиболее важно соблюдать косметические моменты, такие как отступы, комментарии и т.д., не думая о проблемах компиляции. Некто, изучающий программу с целью модификации, может быть озабочен ее размером, поскольку большую программу изучать и дорабатывать сложнее.
Выполнение программ предполагает дополнительный набор проблем, которыми мы можем быть озадачены. Как долго она будет выполняться? Не произойдет ли аварийного завершения? Какие строки были выполнены и сколько раз?  Какие ресурсы (память, файловое пространство, пропускная способность сети, производительность процессора) требуются для выполнения этой программы? Ответы на эти вопросы зависят от входных данных использованных при выполнении программы. Поведение программы зачастую различается для разных входных данных и чтобы сделать заключение о ее поведении, требуется исчерпывающий набор тестовых запусков с разными входными данными, которые могут дать представление о разных аспектах выполнения программы.
Нотация Бекуса-Наура (BNF) предоставляет нам точный способ описания синтаксиса CF Pascal. Вместе с контекстными правилами, синтаксические правила BNF описывают все возможности для разработки программ на CF Pascal. 
Семантика, в противоположность синтаксису, имеет дело со значением программ. Семантика с помощью программного исчисления дает точное представление не того, как программ выглядит, но того, как она управляет Паскаль-машиной. Действия компьютера, выполняемые под управлением программы сложнее описать, чем ее форму на языке программирования. Но суть достаточно проста: описание должно основываться на данных из таблиц выполнения,
оно должно показывать нам, что происходит с переменными и файлами, и какими выражениями программы вызваны те или иные изменения. Тут мы сталкиваемся с проблемой тестовых данных: на каких входных данных должно быть описано поведение программы. Идеальный ответ: «на любых», или «на всех». Полное семантическое описание программы должно включать все варианты. Это означает, что с помощью таблицы выполнения такое описание получить невозможно. 
Семантическое значение для данной CF Pascal программы будет математическое отношение или функция, упорядоченный набор пар, который определяет соответствие между одним набором данных (INPUT) и другим набором данных (OUTPUT). Значением программы будет трансформация данных, описанная следующим соответствием: данным значениям в INPUT соответствуют значения в OUTPUT полученные при выполнении этой программы на  Паскаль-машине. 
 
5. СЕМАНТИКА CF PASCAL.

Глава 5 знакомит нас с концепцией значения программ. Для точного описания этой идеи используются такие математические структуры как строки, списки, множества, отношения и функции.

Знать значение программы – значит быть способным определить выход программы для любого заданного входа. Если для некоторого X на входе программа выдает Y на выходе, то такая пара формирует часть значения функции. Множество всех пар X,Y для которых программа выполняется корректно, является полным значением программы.
Если какие-то входные данные X0 вызывают аварийное завершение или бесконечное выполнение, то X0  н принадлежит значению программы.

Для некоторых программ значения выражаются довольно просто.

PROGRAM Copy (INPUT, OUTPUT);
{Writes first character in INPUT to OUTPUT}
VAR
  Ch: CHAR;
BEGIN
  READ(Ch);
  WRITELN(Ch);
END.

Значение этой программы содержит пары, такие что входная строка не пуста (содержит символы или маркеры конца строки) а выходная строка содержит первый символ входной. Если первый символ входной строки является маркером конца строки, то выходная строка будет содержать символ пробела и такие пары также принадлежат значению программы.

Но большинство программ не могут иметь таких простых и удобных описаний. Они оперируют бесконечным количеством вариантов входных данных и правила определения выходных данных достаточно сложны. Собственно правилом, определяющим выход для данного входа, является сама  программа,  сложные программы обычно склонны иметь большое и сложное значение. Нам потребуется некоторый математически аппарат для работы с программами, такой как строки списки, множества, отношения и функции.

5.1. Строки символов.

Строки символов – математические объекты, , имеющие имена, над ними определены операции и отношения.
Новые идеи: строка символов, символьный литерал, строковый литерал, пустая строка, конкатенация, композиция, декомпозиция, подсписок.

Строковый литерал (или просто строка) - последовательность символов, чье начало и конец помечены специальным символом – маркером строки. 
Строка, не имеющая символов, 0-строка, называется пустой строкой.  Примеры строк:
†† - 0-строка
†?† - 1-строка
†string† - 6-строка
†?string?† - 8-строка

Символьные литералы мы помечаем горизонтальным штрихом над символом, например S для изображения пробелов используем специальный символ ?.
Строковые и символьные литералы не одно и то же, их не нужно путать. 1-строка не то же самое, что символ, который в ней размещается. Например, ? – символ,  †?† - 1-строка.

Строковым литералам удобно присваивать имена, например:  S = †string†.  Строка может иметь несколько имен, но одно имя использовать  для нескольких строк некорректно. Имена лучше всего использовать для именования не каких-то определенных строк, а тех, значение которых мы можем предположить. 

CF Pascal предлагает три операции для манипулирования строками:

Оператор CF Pascal	Строковая операция
WRITE(‘ABC’)	Конкатенация
WRITE(Ch)	Композиция
READ(Ch)	Декомпозиция

Эти операции над строками образуют базис для работы со строками как математическими объектами.

5.1.1. Конкатенация строк.

Выходные данные программы обычно представляют собой строку символов, создаваемую выполнением операторов WRITE. Оператор WRITE, где <список вывода> является <строкой символов>, помещает новую строку вслед за текущими данными в OUTPUT. 

Операция конкатенации в CF Pascal задается оператором WRITE и заключается в помещении строки символов в OUTPUT. Конкатенацией двух строк является третья строка, полученная присоединением второй строки к первой. Например:

C= †character†
S= †string†
C&S=†characterstring†
S&C=†stringcharacter†
S&S=†stringstring†

Для пустой строки справедливо следующее тождество:

† † & S = S & † † = S

Операция конкатенации является бинарной (два операнда, оба - строки), инфиксной (символ операции помещается между операндами), ассоциативной ((C&B)&S = C&(B&S)) и не является коммутативной (S&C ? C & S).

5.1.2. Подстроки.

Строки W = †WRITE(Any, ‘string’)† и строка S = †string† имеют некоторое отношение, а именно символы встречаются внутри W. Говорят, что строка S является подстрокой W.

Строка P является подстрокой Q, если и только если существует строки X и Y, такие что
Q= X & P & Y
В случае с S и W мы можем записать
W = †WRITE(Any, ‘† & S & †’)†
Где согласно определению подстроки 
X = †WRITE(Any, ‘†
Y = †’)†

Или для строки T = †tring†  
S = †s† & T
T- подстрока S и согласно определению подстроки 
X = †s† 
Y = †† 
или
S = †s† & T & †† 

Пустая строка избавляет нас от необходимости вводить специальные правила для случаев, когда подстрока находится на первом месте или завершает строку. Также, пустая строка является подстрокой любой строки.

5.1.3. Композиция строк.

Оператор WRITE может выполнять другую операцию, присоединяя значение переменной типа CHAR к строке, которая является текущим значением OUTPUT. Это операция композиции, обозначаемая знаком ?. Композиция строки и символа – добавление символа к концу строки.

†strin† ? g = †string†

Композиция обеспечивает нам способ превращения символа в строку

† † ? g = †g†

Это общее тождество, связывающее символ и 1-строку содержащую этот символ.
Композиция с пустой строкой настолько полезна, что пустую строку принято опускать и получается унарная префиксная версия композиции:
? g = †g†
Аналогично конкатенации операция композиции является бинарной (первый операнд – строка, второй - символ), инфиксной, ассоциативной  и не является коммутативной.
Следующие варианты недопустимы для композиции

Вариант	Причина
a ? b	Первый операнд – символ
? †x†	Операнд 1-строка, а не символ
N ? ††	Оба операнда выбраны неверно


5.1.3. Декомпозиция строк.

Если оператор WRITE реализует конкатенацию и композицию строк, то оператор READ выполняет разбиение строк. При каждом выполнении оператора READ с одной переменной строка символов в INPUT разделяется на две части. Первый символ в INPUT становится значением символьной переменной, которая используется в выражении READ, а оставшиеся символы становятся текущей строкой для ввода.
Строковые операции голова (head) и хвост (tail) точно описывают то, что происходит при выполнении выражения READ. Глова (?) и хвост (?) – унарные префиксные операции, определенные на непустых строках.

? S – первый символ в строке S
? S – подстрока S полученная удалением первого символа

Например для:
S = †string† 
T = †tring† 

? S = s
? S = †tring† = T
? T = t
? T = †ring†

Поскольку хвост строки – строка, он может служить предметом дальнейшей декомпозиции, например:
? (? T) = r
?(? T) = †ing†
? (?(? T)) = †ng†
? (? (?(? T))) = n
К-й символ строки может быть извлечен К-1 операциями хвост, к результату которых применена операция голова.

Следует выделить следующие моменты:
1.	Операции голова и  хвост не определены на пустых строках
2.	Результат операции голова – символ, операции хвост – строка.
Поскольку голова строки – символ, мы можем превратить его в строку с помощью композиции, далее с помощью конкатенации с хвостом получим исходную строку.
? †string† = s
? †string† = †tring†

?(? †string†) = †s†

(?(? †string†))  &  (? †string†) = †s† & †tring† = †string†

Этот пример описывает фундаментальное тождество, связывающее операции конкатенации, композиции и декомпозиции, а именно: для любой непустой строки S справедливо следующее:

(?(? S))  &  (? S) = S

Следующая таблица обобщает  наши знания о строковых операциях.

Операция	Символ	Пример
конкатенация	&	†me† & †you† = †meyou†
композиция	?	†plural†?s = †plurals†
символ в 1-строку	?	?v = †v†
голова	?	?†feet† = f
хвост	?	?†rattle† = †attle†

5.2. Списковые структуры.

Полезный метод изучения строк – рассматривать строки как последовательность входящих в них подстрок. Например, Паскаль-программа – это строка, составленная из слов, пробелов и специальных символов. И мы знаем, что человеку будет крайне сложно в ней разобраться, если границы между синтаксическими единицами не будут выделены соответствующим образом. В данном случае важны и границы подстрок и порядок их появления и возможность изменения этого порядка. 
Существует структура, представляющая из себя упорядоченный набор объектов, которая называется списком. Список записывается как последовательность, разделенная запятыми ограниченная угловыми скобками.
Например, для строки

†this is a list example†

список литералов

<†th†, †is †, †is †, †a †, †list example†>

предлагает нам вариант нарезки данной строки. Выражение Pascal произведет один и тот же OUTPUT, если будет использована данная строка или список, полученный в результате ее разбиения на подстроки.

WRITE(‘this is a list example’);
WRITE(‘th’, ‘is ‘, ‘is ‘, ‘a ‘, ‘list example’);

Спискам, как и строкам, могут быть присвоены имена, например:

L = <†th†, †is †, †is †, †a †, †list example†>
M = <†this is a list example†>

Приведенные списковые представления строк также являются строками, включая угловые скобки, маркеры границ строк, символы равенства и имена списков. Символы и слова даже в математике используются разными способами и в разных контекстах имеют разное значение. В нашем случае угловые скобки имеют совершенно другой смысл, чем при рассмотрении синтаксиса с помощью BNF.

Если элемент x находится в списке K, мы обозначаем факт как принадлежности списку как
x ? K, если список K не имеет ни одного вхождения объекта x, мы говорим, x ? K.
Например, †is † ? L, но †is † ? M.

Список L содержит пять подстрок, которые могут быть обозначены следующим образом:

L1 = †th†
L2 = †is †
L3 = †is †
L4 = †a †
L5 = †list example†

В то время M как содержит только одну строку

M1 = †this is a list example†
Мы будем использовать индексы для именования элементов списков, используя 1 для обозначения первого элемента и т.д. L можно назвать 5-список, M - 1-список. Список без элементов, 0-список, называется пустым списком и обозначается <>. Необходимо отличать список, содержащий в себе одну строку, от этой строки. Например, M – 1-список с первым и единственным элементом M1 и

M = <M1>, но M ? M1

Также необходимо иметь ввиду, что

<††> ? <>

потому что <††> это 1-спиоск, первый элемент которого пустая строка, а <> - 0-список и первый элемент там отсутствует.

Элементами списков могут быть не только строки, но и символы и другие списки. Например, список 

C = <c, h, a, r, a, c, t, e, r>

Является списком символов и это не то же самое, что строка †character†
Следующий список является списком списков

<M, M> = <<†this is a list example†>, <†this is a list example†>>

где элементами 2-списка являются 1-списки М, рассмотренные выше.
Список может иметь элементы различных видов, например 

Q = <A, <A>, †A†>

Содержит элементы, которые являются соответственно символом, списком и строкой.
Элемент данного списка Q2 содержит единственный элемент – символ A.
(Q2)1 = A

5.2.1. Списковые операции.

Списки могут обрабатываться с использованием операций, подобных тем, что мы определили для строк: конкатенация, композиция и декомпозиция, для которых используются те же символы.

Конкатенацией & двух списков является третий список, полученный присоединением второго к первому. Элементы списка L & M это элементы списка L, дополненные элементами списка M, следующими непосредственно за последним элементом L.


Композиция ? для списков означает присоединение элемента в конец списка. Элементы списка L ??x, это элементы списка L, дополненные x, следующим непосредственно за последним элементом L.

В декомпозиции результатом операции голова ? является первый элемент в списке, если таковой имеется. Результатом операции хвост ? является список, полученный из исходного исключением первого элемента. Операции голова и хвост не определены на пустых списках.

Подсписки определяются аналогично строкам через операцию конкатенации. L является подсписком M, если и только если существуют списки X и Y, такие что

M = X & L & Y

Следующая таблица обобщает наши знания о списковых операциях.

Операция	Символ	Пример
Конкатенация	&	<A> & <A, B> = <A, A, B>
<†12†, <A>> & <X> = <†12†, <A>, X>
Композиция	?	<A> ??????<A,???
<A> ???????<A,????
<A> ??††???<A,?††?
<> ??V???<V?
<> ???††>???<<††>?
Голова	?	?<X, <X>> = X
Хвост	?	?<X, <X>> = <<X>>

Хотя для обозначения порядка элементов в списке используются целые числа, концепция списка не нуждается в натуральных числах. Концепция порядка в последовательности проще и намного примитивнее, чем концепция натуральных чисел. Чтобы определить, какой из двух элементов k и m предшествуют в списке Q сформируем последовательность

? Q, ?(? Q), ?(? (? Q)), …

и определим, где какой из элементов появляется первым k или m.

5.2.2. Описание файлов с помощью списков.

Список как математическая идея хорошо при описании файлов. Рассмотрим INPUT. При выполнении программы, нам необходимо знать только две вещи про INPUT: какая часть данных уже прочитана и какая осталась. В таблицах выполнения это разделение отмечалось курсором.

Если рассмотреть содержимое INPUT как 2-список символьных строк, это формализует разделение на прошлое/будущее и позволяет точно рассуждать о том, что произойдет при выполнении оператора READ. Представим, что INPUT это 2-список L, состоящий из символьных строк. Первая, L1 уже считана (строка прошлого), вторая , L2 – то, что осталось (строка будущего). Таким образом, INPUT представлен списком < L1, L2>. Например, если в таблице выполнения строка символов ABC, тогда

L1 = †A†, L2 = †BC† ??/

где ./ - используемый нами символ маркера конца строки.

Списковые операции могут быть использованы для того, чтобы дать следующее описание выражениям READ и WRITE для одного символа.
Пусть содержимое INPUT список L = < L1, L2>, где L2 ? ††. Тогда оператор READ(Ch) имеет следующее значение.
Ch присваивается значение ? L2
Содержимое INPUT становится < L1??? L2, ? L2>
В вышеприведенном примере для READ(Ch), Ch будет иметь следующее значение.
? L2 = ?(†BC† ??/) = B

а INPUT будет иметь следующее значение:
< L1??? L2, ? L2> 
= <†A†??? (†BC† ??/), ? (†BC† ??/)>
= <†A†??B), †C† ??/)>
= <†A B†), †C† ??/)>

Или, пусть содержимое OUTPUT будет <L1, ††> и v – значение Ch. Тогда WRITE(Ch) имеет следующее значение: содержимое OUTPUT становится <L1 ? v, ††>.

Описание файла как 2-списка достаточно точно, но оно не адекватно для описания требований CF Pascal к файловым операциям. Например, оператор READ не может быть выполнен для OUTPUT. Файловые переменные описанные как TEXT, могут считываться и записываться, но в соответствии с определенными правилами. Например, последовательность
REWRITE(F1);
WRITE(F1, Ch);
WRITELN(F1);
RESET(F1);
READ(F1, Ch);
Является допустимой, но
REWRITE(F2);
WRITE(F2, Ch);
READ(F2, Ch);
допустимой не является, потому что к F2 перед выполнением оператора READ должно быть применен оператор RESET.
Для того, чтобы зафиксировать использование фалов формально, в описание файла нужно ввести дополнительную информацию, поэтому мы расширим 2-список до 3-списка, содержащего строку прошлого, строку будущего и состояние файла, которое может быть символом R или W, которые обозначают доступен ли файл для чтения или для записи.
Полные правила для состояний фалов даны в следующей таблице переходов, где пустые ячейки означают недопустимую операцию.

Исходное состояние	Применяемая операция и новое состояние файла
	RESET	REWRITE	READ/READLN	WRITE/WRITELN
R	R	W	R	
W	R	W		W

Например, если состояние файла R, выражение REWRITE переводит его в состояние W. Пустая ячейка под READ/READLN c строке W означает, что в состоянии W к файлу неприменимы операции чтения.

В следующей таблице приведены значения для выражений READ и WRITE и использованием значений файлов в форме 3-списка. Таблица не описывает недопустимые комбинации.

	F1	Ch
(изначально v)
	до	после	
REWRITE(F1)	<x, y, t>	<††, ††, W>	
WRITE(F1, Ch)	<x, ††, W>	<x?v, ††, W>	v
WRITELN(F1, Ch)	<x, ††, W>	<x?v??, ††, W>	v
RESET(F1)	<x, y, t>	<††, x&y, R>	
READ(F1, Ch)	<x, y??, R>	<x???(y????, ?(y???, R>	?(y???
READLN(F1)	<x, (y?/)&z, R>
(y не содержит /)	<x&(y?/), z, R>	?(y???

Например, первая строка в таблице представляет значение выражения REWRITE. Оно преобразует состояние  <x, y, t> в <††, ††, W> для любых строк x, y и состояния файла t.

Таблица выполнения ниже демонстрирует успешные операции над файлами в форме 3-списка.
	F1	Ch
VAR
  Ch:CHAR;
  F1: TEXT;
BEGIN
  Ch := ‘A’;
  REWRITE(F1);
  WRITE(F1, Ch);
  Ch := ‘B’;
  WRITELN(F1);
  RESET(F1);
  READ(F1, Ch);
  READ(F1, Ch);
END.	

?


<††, ††, W>
<†A†, ††, W>

<†A†???, ††, W>
<††, †A†???? R>
<†A†, ††???? R>
<†A†???, ††? R>	
?


A


B


A
?


После первого оператора READ EOLN принимает значение TRUE, после последнего оператора READ EOF становится TRUE, и если бы программа выполнила еще один оператор READ, то произошло бы аварийное завершение ее работы.

5.3. Множества

Множества – наборы объектов, где не имеет значение порядок и повторяемость элементов. Множества это основное математическое понятие, на котором базируются отношения и функции.

Новые идеи: Множество, принадлежность множеству, подмножество, мощность множества, операции над множествами, объединение, пересечение, разность (различность).


Строки и списки – это наборы объектов, к которых порядок и повторение элементов имеют значение. Набор данных, в котором порядок и повторение элементов не имеет значения называется множеством. Во множестве элементы просто сгруппированы и никакой не является первым или следующим и не повторяется. 

Элементы множества записываются в фигурных скобках. Конечно, элементы множества имеют определенный порядок при записи, но он не существенен. Например:
{A, B} и {B, A} описывают одно и то же множество.
Любой список задает множество, элементами которого являются элементы списка (множество элементов списка). Например, список

L = <†th†, †is †, †is †, †a †, †list example†>
Имеет множество его элементов

S = {†th†, †is †, †a †, †list example†}

В котором повторяющийся элемент †is † появляется только один раз. Поскольку порядок элементов не имеет значения, это же множество может быть записано в виде

S = {†list example†, †a †, †is †,†th† } = {†th†,  †a †, †list example†, †is †}

Мы будем упоминать размер, говоря о  множествах, например S можно назвать 4-множеством. 
Элементы множества не обязательно должны быть одного типа, например следующее 3-множество

{A, †mixed†, <†can†, {†of†, †beans†}>}

содержит элемент символ, строку, и 2-список, который в свою очередь содержит строку и 2-множество, элементы которого являются строками.

Фундаментальная связь между элементом и множеством является его принадлежность данному множеству, для обозначения используется символ ?. В примере приведенном выше 

†list example† ? S
но 
†list † ? S

Множество, не имеющее элементов называется пустым множеством и записывается {}. Пустое множество отличается от пустого списка <>. Например для <> может быть выполнена конкатенация с  другим списком, но это невозможно для {}. 1-множество называется одиночка (singleton). 1-множество отличается от его единственного элемента, и от списка с таким элементом. Например:

	†string† ? {†string†} ? <†string†>

Множество S является подмножеством T, S ? T , если каждый элемент S является элементом T. Таким образом, S ? T если и только если для каждого x, x ? T если x ? S.

Множества S и T равны, S = T, если им принадлежать одни и те же элементы. Таким образом, S = T, если и только если S ? T и T ? S.

Пустое множество является подмножеством любого множества, включая себя самого, поскольку оно не имеет элементов, то значит в нем нет элемента, которого может не оказаться в любом другом множестве. Таким образом {} ? S, для любого S.

Если множества S и T не имеют общих элементов, то говорят, что они не пересекающиеся.

5.3.1. Правила описания множеств.

Альтернативой явному перечислению элементов множества является set-нотация, где мы помещаем  имя обобщенного элемента множества и через двоеточие описываем его. Например:

T = {x: x – любое слово в строке †this is a rule†} = {†this†, †is†, †a†, †rule†}

Обычно такая запись читается как, «множество всех x, таких что…». Чтобы принадлежать множеству, элемент должен удовлетворять условию, записанному после двоеточия.
Условие, описывающее принадлежность множеству может иметь несколько частей. Например, запись для множества 

U = {x: x = <y, z>, 	y – любое слово в строке †this one list†, 
z любой символ в строке †AB†}

означает, что x одновременно удовлетворяет трем условиям:
1.	x должен быть 2-списком
2.	x1 должен быть словом в †this one list†
3.	x1 должен быть символом в †AB†

Поскольку †this one list† содержит 3 слова, а †AB† два символа, множество U будет содержать 6 элементов, а именно:

U = {<†this†, A>, <†this†, B>, <†one†, A>, <†one†, B>, <†list†, A>, <†list†, B>}

Обобщенный элемент множества может быть структурой такой как список или множество. Таким образом, форма записи обобщенного элемента может содержать в себе часть условия. Например, U может быть описано следующим образом:
U = {<y, z>: 	y – любое слово в строке †this one list†, z любой символ в строке †AB†}
Если описание  обобщенного элемента может быть более информативным, это обычно делается, потому что уменьшается количество условий, следующих после двоеточия. Например:
{<x, y>: x – строка, y = x????}
будет записано как
{<x, x????>: x – строка}

Ситуация когда элементами множества являются другие множества случается настолько часто, что ей дали собственное название. Множеством мощности для любого множества S является множество всех подмножеств S, обозначаемое power(S). 

Например, если 

T = {†this†, †is†, †a†, †rule†}
тогда
power(T) = {U: U ? T} = {{}, {†this†}, {†is†},…, {†a†, †is†, †rule†}, T}

содержащее одно 0-множество, четыре 1-множества, шесть 2-множеств, четыре 3-множества и одно 4-множество, или 1+4+6+4+1=16 элементов. То, что 16 =24 не случайно. Для каждого из четырех элементов множества есть два варианта построения подмножества – с этим элементом и без него. Таким образом, количество членов в множестве мощности будет 2x2x2x2=16. В общем случае если S – n-множество, то power(S) будет 2n. 
Set-нотация наиболее полезна, когда описываемые множества велики или бесконечны. Например, множество

{p: p – Паскаль-программа}

не может быть описано перечислением его элементов.

5.3.2. Операции над множествами.

Множества можно комбинировать для формирования новых множдеств и эти операции особенно полезны.

Объединение:		S ? T = {x: x ? S или x ? T}
Разность		S – T = {x: x ? S, x ? T}    			[различность]
Пересечение  		S ? T = {x: x ? S, x ? T}

Эти операции легко визуализировать с помощью диаграмм Венна.

S ? T	S – T	S ? T




	

Если два множества находятся внутри третьего множества, то их объединение, разность и пересечение, также остаются внутри этого множества, т.е. если S ? U и T ? U, тогда
S ? T ? U
S – T ? U
S ? T ? U
Для любого множества S, пустое множество обнаруживает следующие свойства:
S ? {} = S ? {} = S
S – {} = S, {} - S = {}
S ? {}  = {} ? S = {}
Объединение и пересечение коммутативны, т.е.
S ? T = T ? S
S ? T  = T ? S
и ассоциативны, т.е.
R ? (S ? T) = (R ? T) ? S
R ? (S ? T) = (R ?T) ? S
Таким образом, нет необходимости в скобках для указания порядка при записи нескольких объединений и пересечений.
Разность не коммутативна и не ассоциативна.

Примеры. Пусть 
S = {†this†, †is†, †a†, †set†}
T = {†this†, †is†, †another†, †set†}
тогда
S ? T 			= T ? S ={†this†, †is†, †a†, †set†, †another†}
S – T  			= {†a†}
T – S 			= {†another†}
S ? T 			= {†this†, †is†, †set†}
(S – T) ? (S ? T)	= {†this†, †is†, †a†, †set†}
(S – T) ? (S ? T)	= {}

Следующая таблица обобщает характеристики операций над множествами.

Операция	Символ	Описание	Свойства
Объединение	?	S ? T = {x: x ? S или x ? T}	ассоциативная,
коммутативная
Пересечение	?	S ? T = {x: x ? S, x ? T}	ассоциативная,
коммутативная
Разность	-	S – T = {x: x ? S, x ? T}	не ассоциативная,
не коммутативная


5.3.3. Отношения и функции.

Любое множество 2-списокв или пар называется отношением. Отношения будут особенно полезны при обсуждении значения программ.
Слово «отношение» может означать правило сравнения, «эквивалентность» или «является подмножеством» и т.д. Формально отношения, которые являются множествами 2-списков, могут описать эти неформальные правила точно, путем включения точно тех пар, чьи элементы состоят в нужной связи друг с другом. Например, отношение между символами и 1-строками содержащими эти символы задается следующим отношением:

C = {<x, ?x>: x - символ} = {<a, †a†>, <b, †b†>, …}

Поскольку отношение это множество, пустое отношение также возможно. Например, соответствие между четными натуральными числами и их нечетными квадратами – таких не существует. Более того, операции над множествами применимы к отношениям. Если s и r отношения, то существуют
s ? r, s – r, s ? r
поскольку это множества упорядоченных пар элементов.

Частный случай отношения – функция, отношение со специальным свойством, отличающееся тем, что каждый первый элемент находится в паре с уникальным вторым элементом. Отношение r является функцией, если и только если для любого 

<x, y> ? r и <x, z> ? r, то y = z.

В таком случае каждый первый элемент может служить именем для второго в контексте отношения. Например, описанное выше отношение C между символами и 1-строками является функцией.

Операции над множествами также применимы к функциям. Хотя результат операции над множествами упорядоченных пар, которые являются функциями, будет обязательно другим множеством упорядоченных пар, а следовательно отношением, но не всегда функцией.
Если f,g –функции, то f ? g, f – g тоже функции, но f ? g, может быть а может и не быть функцией. Например, определим отношение голова

H = {< ? y, y>: y - строка} = {<a, †a†>, <a, †aa†>, …}

И возьмем отношение C, описанное выше. Тогда из факта, что C ? H:
C ? H = C
является функцией,

H - С = {< ? y, y>: y – строка как минимум из 2 символов}
является отношением, но не функцией,

C – H = {}
является пустой функцией, и
C ? H = H
является отношением.

Множество первых элементов пар отношения или функции называется областью определения (domain), а множество вторых элементов пар называется областью значений (range). Для элементов отношения , скажем <x, y> ? r, x называется аргументом r, а у называется значением r.

Когда <x, y> ? r и и y является единственным значением для x, value-нотация:
y=r(x)
читается, как «y является значением r для аргумента x» или, более кратко, «y является значением r для x» (функциональная форма записи). 

Зададим произвольное отношение r и аргумент x, тогда существуют три варианта их соответствия:
1.	x ? domain(r), в таком случае r не определено на x
2.	x ? domain(r), и существуют различные y, z, такие что <x, y> ? r и <x, z> ? r. В этом случае r неоднозначно определено на x
3.	x ? domain(r), и существует уникальная пара <x, y> ? r. В этом случае r однозначно определено на x и y=r(x).

Таким образом, функция – это отношение, которое однозначно определено для всех элементов его области определения.

Выделяют три специальные функции:

Пустая функция {}, не имеет аргументов и значений, то есть 
domain({}) = {}, range({}) = {}

Функция эквивалентности (identity function), функция I такая, 
что если x ? domain(r), тогда I(x) = x.

Постоянная функция, область значений которой задается 1-множеством, то есть всем аргументам соответствует одно и то же значение.

Поскольку отношения и функции являются множествами, они могут быть описаны перечислением элементов или заданием правил. Например:

r = {<†ball†, †bat†>, <†ball†, †game†>, <†game†, †ball†>}

является отношением, поскольку все его элементы - 2-списки

domain(r) = {†ball†, †game†}
range (r) = {†ball†, †game†, †bat†}

Однако, r не является функцией, потому что два разных значения встречаются в паре с одним аргументом †ball†.

Пример отношения, определенного с помощью правила:

s = {<x, y>: слово x непосредственно предшествует слову y 
в строке †this is a relation that is not a function†}

Это отношение также может быть задано перечислением:

s = {<†this†, †is†>, <†is†, †a†>, <†a†, †relation†>, <†relation†, †that†>, 
<†that†, †is†>, <†is†, †not†>, <†not†, †a†>, <†a†, †function†>}

Следующее правило определяет функцию:
f = {<x, y>: первый экземпляр слова непосредственно предшествующий слову y 
в строке †this is a relation that is also a function†}
которая также может быть задана перечислением:
f = {<†this†, †is†>, <†is†, †a†>, <†a†, †relation†>,
 <†relation†, †that†>, <†that†, †is†>, <†also†, †a†>}

5.4. Значение программ.

Отношения и функции жизненно необходимы для описания  для описания значения программ. Используя эти понятия, разрабатывается нотация для описания значения программ. Для простых программ значение будет очевидным, но эти простые примеры послужат освоению теории в целом. 

Новые идеи: box-нотация, программа и значение программы.

Множество пар ввод-вывод для всех возможных нормальных запусков программы называется значением программы. Также может быть использованы понятия функция программы и отношение программы. Важно различать значение программы и элементы значения.  Для конкретного входа Паскаль-машина, управляемая Паскаль-программой может произвести конкретный выход. Но значение программы это гораздо больше, чем способ выражения результата одного частного выполнения. Оно выражает все возможные выполнения Паскаль-программы на Паскаль-машине.
Программа может принимать вход разбиты на строки и производить выход разбитый на строки . Таким образом пары в значении программы могут быть парами списков состоящих из строк символов.

5.4.1. Box-нотация.

Любая Паскаль-программа – строка символов, передаваемая для обработки Паскаль-машине. Например:

P = †PROGRAM PrintHello (INPUT, OUTPUT); BEGIN WRITELN(‘HELLO’) END.†

Представляет одну из первых программ, рассмотренных в начале части I, в виде строки.
Также эту строку можно записать, опустив маркеры строки, как 

P = 	PROGRAM PrintHello (INPUT, OUTPUT); 
BEGIN 
  WRITELN(‘HELLO’) 
END.

Строка P представляет синтаксис программы, а ее значение мы будем записывать как P. Значение P это множество 2-списков (упорядоченных пар) списков символьных строк, в которых аргументы представляют входные данные программы, а значения представляют выходные данные программы, то есть

P = {<L, M>: для входного списка строк L, P выполняется корректно 
и возвращает список строк M}

Box-нотация для значения программы держит синтаксис и семантику программы, но ясно разграничивает одно от другого. Для программы PrintHello, приведенной выше:

P = {<L, M: L – любой список строк, а M – 1-список <†HELLO†> } =
	{<L, <†HELLO†>>: L – любой список строк }

Помещая текст программы в box:

P = PROGRAM PrintHello (INPUT, OUTPUT); BEGIN WRITELN(‘HELLO’) END

Поскольку P - функция,

PROGRAM PrintHello (INPUT, OUTPUT); BEGIN WRITELN(‘HELLO’) END (L) = <†HELLO†>

для любого списка строк L.

Box-нотация скрывает способ которым программа управляет Паскаль-машиной и показывает только то что сопутствует выполнению. Термин «черный ящик» часто используется для описания механизма рассматриваемого только извне в терминах входов и выходов. Таким образом эта нотация подходит для значения программы с точки зрения ввода-вывода. Например, программа R 
PROGRAM PrintHelloInSteps (INPUT, OUTPUT); 
BEGIN 
  WRITE(‘HE’); 
  WRITE (‘L’); 
  WRITELN(‘LO’) 
END.

Имеет то же значение что и P, то есть R = P.

Программ R также имеет CFPascal имя PrintHelloInSteps. Но поскольку строка †PrintHelloInSteps† является частью строки R, лучше не использовать PrintHelloInSteps в качетсве названия программы R в box-нотации.

5.4.2. Прямое определение значения программы.

Следующие главы будут развивать программное исчисление, что позволит вычислять P для любой программы. Однако, часто в простых случаях возможно определить P неформально, точно зафиксировав что делает программа P с помощью неформального анализа.

Любая программа, используя оператор READ, может встретить маркер конца строки или конца файла, что усложняет значение программы. Например, пусть Q – программа:

PROGRAM ReadWriteRead(INPUT, OUTPUT); 
VAR 
  Ch: CHAR;
BEGIN 
  READ(Ch); 
  WRITELN(Ch); 
  READ(Ch)
END.

Входной файл может быть организован как список строк, каждая из которых завершена маркером конца строки. Здесь есть несколько вариантов, которые следует рассмотреть.
Если список пуст, первый оператор READ приведет к ошибке выполнения. Если INPUT - 1-список, и его единственная строка – пустая строка, первый оператор READ прочитает маркер конца строки (как пробел), а второй приведет к аварийному завершению работы.
Если первая строка в INPUT не пуста, тогда первый оператор READ возвратит первый символ, второй оператор READ вернет либо второй символ, либо маркер конца строки, если второй символ отсутствует. В этом случае Q выполняется корректно и выводит первый символ первой строки INPUT в OUTPUT. Если INPUT 2- или более-список, и первая строка пуста, тогда оператор READ возвращает символ конца строки как пробел, а второй оператор RED берет первый символ второй строки, если таковой имеется, или ее маркер конца строки. В этом случае Q выполняется корректно и записывает пробел в OUTPUT. Этот анализ суммируется в следующей нотации для Q, как преобразования INPUT в OUTPUT.

Q = {<L, M>: L ? <>, L1 ? ††, M = <???? L1)>,} ? 
	{<L, M>: L ? <>, ? L ? <>, L1 = ††, M =†?†}

Отметим, что здесь L1, первый элемент списка L здесь означает первую строку в INPUT.
Область определения и область значений Q могут быть определены прямо из Q путем нахождения первого и второго элементов в парах. Область определения – список строк 

domain (Q) = {L : L ? <>, L1 ? †† } ? { L : L  ? <>, ? L ? <>, L1 = ††}

Для range (Q) вторые элементы пар 1-списки 1-строк, и единственный символ это либо начальный символ строки или пробел. Таким образом, 

range (Q) = {M : M – 1-список, содержащий 1-строку}

Необходимо отметить, что значение программы просто пропускает пары, для которых не существует корректное выполнение, например, для которых L – пустой список или 1-список с элементом - пустой первой строкой.

Рассмотрим R:

PROGRAM CopyTwice(INPUT, OUTPUT); 
VAR 
  Ch: CHAR;
BEGIN 
  READ(Ch); 
  READ(Ch); 
  WRITE (Ch); 
  WRITELN(Ch); 
END.

Для того, чтобы записать значение R, нужно найти второй символ, если таковой есть списка строк L в INPUT, учитывая встречаемость строковых маркеров.


Условия	Комментарии
L = <>	аварийное завершение
L ? <>	рассмотреть L1
  L1 = ††	рассмотреть существование L2
    ? L = <>	аварийное завершение
    ? L ? <>	рассмотреть L2
     L2 = ††	напечатать пробел дважды
     L2 ? ††	напечатать дважды ? L2
  L1 ? ††	рассмотреть L1
    ? L1 = ††	напечатать пробел дважды
    ? L1 ? ††	напечатать дважды ? (? L1)

Как результат этого анализа значение R будет:

R = 	{<L, M>: L ? <>, L1 = ††, ? L ? <>, L2 = ††, M = <†??†>} ?
	{<L, M>: L ? <>, L1 = ††, ? L ? <>, L2 ? ††, M = <(??? L2))???? L2)>} ?
	{<L, M>: L ? <>, L1 ? ††, ? L1 = ††, M = <†??†>} ?
	{<L, M>: L ? <>, L1 ? ††, ? L1 ? ††, M = <(??? (? L1)))???? (? L1))>}.

5.5. Заключение

Строки, списки и множества обеспечивают необходимый инструментарий для точного определения значений CF Pascal программ. Строки и списки используют операции конкатенации (&), композиции (?)б и декомпозиции (? и ?). Рассматривая текстовые файлы как 3-список мы можем дать точное описание файловым манипуляциям, включая все сложные ситуации с границами строки допустимые последовательности операций.
Для множеств определены операции объединения (?), пересечения (?), и разности (–). Множества базовые математические понятия, используемые при создании отношений и функций, которые используются для анализа значений программ.
Box-нотация различает синтаксический аспект программы P (ее символьная строка) и семантический аспект P (функция ее значения).
